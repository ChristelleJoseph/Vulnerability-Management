import os
import logging
from dotenv import load_dotenv
from flask import Flask, jsonify, request, send_from_directory
import requests
from datetime import datetime, timedelta
import openai
from concurrent.futures import ThreadPoolExecutor
from collections import OrderedDict

load_dotenv('.env')

app = Flask(__name__)

openai.api_key = os.getenv('OPENAI_API_KEY')

logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(levelname)s %(message)s')

@app.route('/')
def serve_index():
    return send_from_directory('.', 'index.html')

def get_vulnerabilities_for_today(results_per_page=1, max_vulnerabilities=1):
    logging.debug("Fetching vulnerabilities for today")
    today = datetime.utcnow().date()
    start_date = datetime.combine(today, datetime.min.time())
    end_date = start_date + timedelta(days=1)

    url = 'https://services.nvd.nist.gov/rest/json/cves/2.0'
    vulnerabilities = []
    start_index = 0

    while len(vulnerabilities) < max_vulnerabilities:
        params = {
            'startIndex': start_index,
            'resultsPerPage': results_per_page,
            'pubStartDate': start_date.strftime('%Y-%m-%dT%H:%M:%S.%fZ'),
            'pubEndDate': end_date.strftime('%Y-%m-%dT%H:%M:%S.%fZ')
        }

        response = requests.get(url, params=params)
        if response.status_code != 200:
            logging.error(f"Error fetching vulnerabilities: {response.status_code}")
            break

        data = response.json()
        vulnerabilities.extend(data.get('vulnerabilities', []))

        if len(data.get('vulnerabilities', [])) < results_per_page:
            break

        start_index += results_per_page

    logging.debug(f"Vulnerabilities fetched: {vulnerabilities}")
    return vulnerabilities[:max_vulnerabilities]

def interpret_vulnerability(description):
    logging.debug(f"Interpreting vulnerability: {description}")
    prompt = f"You are a cybersecurity expert. Analyze the following vulnerability and provide potential impact and mitigation steps: {description}"

    try:
        response = openai.Completion.create(
            model="gpt-3.5-turbo-instruct",
            prompt=prompt,
            max_tokens=200
        )
        logging.debug(f"OpenAI response: {response}")
        return response.choices[0].text.strip()
    except Exception as e:
        logging.error(f"OpenAI API call failed: {e}")
        return "OpenAI API call failed."

def get_vulnerability_info(vulnerability):
    try:
        cve_data = vulnerability.get('cve', {})
        cve_id = cve_data.get('id', 'N/A')
        description = cve_data.get('descriptions', [{'value': 'No description available'}])[0]['value']
        raw_date = cve_data.get('published', 'N/A')
        publication_date = datetime.strptime(raw_date, "%Y-%m-%dT%H:%M:%S.%f").strftime("%Y-%m-%d") if raw_date != 'N/A' else 'N/A'

        severity = 'Unknown'
        impact = 'Unknown'

        if 'metrics' in cve_data:
            if 'cvssMetricV31' in cve_data['metrics']:
                cvss_v3 = cve_data['metrics']['cvssMetricV31'][0]
                severity = cvss_v3['cvssData']['baseSeverity']
                impact = cvss_v3['cvssData']['attackVector']
            elif 'cvssMetricV2' in cve_data['metrics']:
                cvss_v2 = cve_data['metrics']['cvssMetricV2'][0]
                severity = cvss_v2['baseSeverity']
                impact = cvss_v2['accessVector']

        analysis = interpret_vulnerability(description)

        return OrderedDict([
            ('cve_id', cve_id),
            ('date', publication_date),
            ('description', description),
            ('severity', severity),
            ('impact', impact),
            ('analysis', analysis)
        ])
    except Exception as e:
        logging.error(f"Error processing vulnerability: {e}")
        return OrderedDict([
            ('cve_id', 'N/A'),
            ('date', 'N/A'),
            ('description', 'Incomplete data'),
            ('severity', 'N/A'),
            ('impact', 'N/A'),
            ('analysis', 'N/A')
        ])

def process_vulnerabilities(vulnerabilities):
    logging.debug("Processing vulnerabilities")
    if not vulnerabilities:
        return jsonify([])

    with ThreadPoolExecutor() as executor:
        result = list(executor.map(get_vulnerability_info, vulnerabilities))

    result = sorted(result, key=lambda x: x['date'], reverse=True)
    logging.debug(f"Processed vulnerabilities: {result}")
    return result

@app.route('/vulnerabilities', methods=['GET'])
def get_vulnerabilities():
    logging.debug("GET /vulnerabilities endpoint called")
    vulnerabilities = get_vulnerabilities_for_today()
    result = process_vulnerabilities(vulnerabilities)
    return jsonify([dict(v) for v in result])

@app.route('/webhook', methods=['POST'])
def webhook():
    logging.debug("Webhook called")
    req = request.get_json(silent=True, force=True)
    logging.debug(f"Request JSON: {req}")
    intent_name = req.get('queryResult').get('intent').get('displayName')

    if intent_name == 'FetchVulnerabilities':
        try:
            vulnerabilities = get_vulnerabilities_for_today()
            result = process_vulnerabilities(vulnerabilities)

            response_text = "Here are today's vulnerabilities:\n\n"
            for v in result:
                response_text += (
                    f"Id: {v['cve_id']}\n\n"
                    f"Date: {v['date']}\n\n"
                    f"Description: {v['description']}\n\n"
                    f"Severity: {v['severity']}\n\n"
                    f"Impact: {v['impact']}\n\n"
                    f"**AI analysis**:\n\n"
                    f"{v['analysis']}\n\n"
                )
            logging.debug(f"Response text: {response_text}")
            return jsonify({'fulfillmentText': response_text})
        except Exception as e:
            logging.error(f"Error in FetchVulnerabilities intent: {e}")
            return jsonify({'fulfillmentText': f"An error occurred: {str(e)}"})

    return jsonify({'fulfillmentText': 'Unable to handle the request.'})

if __name__ == '__main__':
    logging.info("Starting Flask app")
    app.run(debug=True, port=5003)
