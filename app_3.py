from flask import Flask, jsonify, request
import requests
from datetime import datetime, timedelta
import openai
import time
from concurrent.futures import ThreadPoolExecutor
import logging

app = Flask(__name__)


logging.basicConfig(level=logging.INFO)

def fetch_vulnerabilities_for_today(results_per_page=10, max_vulnerabilities=10):
    start_time = time.time()
    today = datetime.utcnow().date()
    start_date = datetime.combine(today, datetime.min.time())
    end_date = start_date + timedelta(days=1)

    logging.info(f"Fetching vulnerabilities for {today}")

    url = 'https://services.nvd.nist.gov/rest/json/cves/2.0'
    vulnerabilities = []
    start_index = 0

    while len(vulnerabilities) < max_vulnerabilities:
        params = {
            'startIndex': start_index,
            'resultsPerPage': results_per_page,
            'pubStartDate': start_date.strftime('%Y-%m-%dT%H:%M:%S.%fZ'),
            'pubEndDate': end_date.strftime('%Y-%m-%dT%H:%M:%S.%fZ')
        }

        logging.info(f"Making request to {url} with params {params}")

        response = requests.get(url, params=params)
        if response.status_code != 200:
            logging.error(f"Error fetching data: {response.status_code}")
            break

        data = response.json()
        logging.info(f"Fetched {len(data.get('vulnerabilities', []))} vulnerabilities")
        vulnerabilities.extend(data.get('vulnerabilities', []))

        if len(data.get('vulnerabilities', [])) < results_per_page:
            break

        start_index += results_per_page

    vulnerabilities = vulnerabilities[:max_vulnerabilities]

    fetch_time = time.time() - start_time
    logging.info(f"Time taken to fetch data: {fetch_time:.2f} seconds")
    return vulnerabilities

def interpret_vulnerability(description):
    start_time = time.time()
    prompt = f"Analyze the following vulnerability and provide a summary, potential impact, and mitigation steps: {description}"

    response = openai.Completion.create(
        model="gpt-3.5-turbo-instruct",
        prompt=prompt,
        max_tokens=150  # Reduce the max_tokens to speed up the response
    )
    interpret_time = time.time() - start_time
    logging.info(f"Time taken to interpret vulnerability: {interpret_time:.2f} seconds")

    return response.choices[0].text.strip()

def get_vulnerability_info(v):
    try:
        logging.info(f"Processing CVE Data: {v}")
        cve_data = v.get('cve', {})
        cve_id = cve_data.get('id', 'N/A')
        description = cve_data.get('descriptions', [{'value': 'No description available'}])[0]['value']
        raw_date = cve_data.get('published', 'N/A')
        if raw_date != 'N/A':
            publication_date_obj = datetime.strptime(raw_date, "%Y-%m-%dT%H:%M:%S.%f")
            publication_date = publication_date_obj.strftime("%Y-%m-%d")
        else:
            publication_date = 'N/A'

        severity = 'Unknown'
        impact = 'Unknown'

        if 'metrics' in cve_data and 'cvssMetricV31' in cve_data['metrics']:
            cvss_v3 = cve_data['metrics']['cvssMetricV31'][0]
            severity = cvss_v3['cvssData']['baseSeverity']
            impact = cvss_v3['cvssData']['attackVector']
        elif 'metrics' in cve_data and 'cvssMetricV2' in cve_data['metrics']:
            cvss_v2 = cve_data['metrics']['cvssMetricV2'][0]
            severity = cvss_v2['baseSeverity']
            impact = cvss_v2['accessVector']

        recommendation = interpret_vulnerability(description)

        return {
            'cve_id': cve_id,
            'date': publication_date,
            'description': description,
            'severity': severity,
            'impact': impact,
            'recommendation': recommendation
        }
    except Exception as e:
        logging.error(f"Error processing vulnerability info: {str(e)} - Data: {v}")
        return {
            'cve_id': 'N/A',
            'date': 'N/A',
            'description': 'Incomplete data',
            'severity': 'N/A',
            'impact': 'N/A',
            'recommendation': 'N/A'
        }

@app.route('/vulnerabilities', methods=['GET'])
def get_vulnerabilities():
    vulnerabilities = fetch_vulnerabilities_for_today()
    result = []

    with ThreadPoolExecutor() as executor:
        result = list(executor.map(get_vulnerability_info, vulnerabilities))

    result = sorted(result, key=lambda x: x['date'], reverse=True)
    return jsonify(result)

@app.route('/webhook', methods=['POST'])
def webhook():
    req = request.get_json(silent=True, force=True)
    logging.info(f"Request: {req}")

    intent_name = req.get('queryResult').get('intent').get('displayName')
    logging.info(f"Intent: {intent_name}")

    if intent_name == 'FetchVulnerabilities':
        try:
            vulnerabilities = fetch_vulnerabilities_for_today()
            result = []

            with ThreadPoolExecutor() as executor:
                result = list(executor.map(get_vulnerability_info, vulnerabilities))

            result = sorted(result, key=lambda x: x['date'], reverse=True)

            response_text = "Here are today's vulnerabilities:\n"
            for v in result:
                response_text += (
                    f"ID: {v['cve_id']}\n"
                    f"Date: {v['date']}\n"
                    f"Description: {v['description']}\n"
                    f"Severity: {v['severity']}\n"
                    f"Impact: {v['impact']}\n"
                    f"Recommendation: {v['recommendation']}\n\n"
                )
            logging.info(f"Response: {response_text}")
            return jsonify({'fulfillmentText': response_text})
        except Exception as e:
            logging.error(f"Error: {str(e)}")
            return jsonify({'fulfillmentText': f"An error occurred: {str(e)}"})

    else:
        logging.info("Unknown intent")
        return jsonify({'fulfillmentText': 'I am not sure how to handle that request.'})

if __name__ == '__main__':
    app.run(debug=True, port=5003)
